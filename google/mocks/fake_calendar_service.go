// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"
	"time"

	"github.com/inference-gateway/google-calendar-agent/google"
	calendar "google.golang.org/api/calendar/v3"
)

type FakeCalendarService struct {
	CreateEventStub        func(string, *calendar.Event) (*calendar.Event, error)
	createEventMutex       sync.RWMutex
	createEventArgsForCall []struct {
		arg1 string
		arg2 *calendar.Event
	}
	createEventReturns struct {
		result1 *calendar.Event
		result2 error
	}
	createEventReturnsOnCall map[int]struct {
		result1 *calendar.Event
		result2 error
	}
	DeleteEventStub        func(string, string) error
	deleteEventMutex       sync.RWMutex
	deleteEventArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteEventReturns struct {
		result1 error
	}
	deleteEventReturnsOnCall map[int]struct {
		result1 error
	}
	GetEventStub        func(string, string) (*calendar.Event, error)
	getEventMutex       sync.RWMutex
	getEventArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getEventReturns struct {
		result1 *calendar.Event
		result2 error
	}
	getEventReturnsOnCall map[int]struct {
		result1 *calendar.Event
		result2 error
	}
	ListCalendarsStub        func() ([]*calendar.CalendarListEntry, error)
	listCalendarsMutex       sync.RWMutex
	listCalendarsArgsForCall []struct {
	}
	listCalendarsReturns struct {
		result1 []*calendar.CalendarListEntry
		result2 error
	}
	listCalendarsReturnsOnCall map[int]struct {
		result1 []*calendar.CalendarListEntry
		result2 error
	}
	ListEventsStub        func(string, time.Time, time.Time) ([]*calendar.Event, error)
	listEventsMutex       sync.RWMutex
	listEventsArgsForCall []struct {
		arg1 string
		arg2 time.Time
		arg3 time.Time
	}
	listEventsReturns struct {
		result1 []*calendar.Event
		result2 error
	}
	listEventsReturnsOnCall map[int]struct {
		result1 []*calendar.Event
		result2 error
	}
	UpdateEventStub        func(string, string, *calendar.Event) (*calendar.Event, error)
	updateEventMutex       sync.RWMutex
	updateEventArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *calendar.Event
	}
	updateEventReturns struct {
		result1 *calendar.Event
		result2 error
	}
	updateEventReturnsOnCall map[int]struct {
		result1 *calendar.Event
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCalendarService) CreateEvent(arg1 string, arg2 *calendar.Event) (*calendar.Event, error) {
	fake.createEventMutex.Lock()
	ret, specificReturn := fake.createEventReturnsOnCall[len(fake.createEventArgsForCall)]
	fake.createEventArgsForCall = append(fake.createEventArgsForCall, struct {
		arg1 string
		arg2 *calendar.Event
	}{arg1, arg2})
	stub := fake.CreateEventStub
	fakeReturns := fake.createEventReturns
	fake.recordInvocation("CreateEvent", []interface{}{arg1, arg2})
	fake.createEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCalendarService) CreateEventCallCount() int {
	fake.createEventMutex.RLock()
	defer fake.createEventMutex.RUnlock()
	return len(fake.createEventArgsForCall)
}

func (fake *FakeCalendarService) CreateEventCalls(stub func(string, *calendar.Event) (*calendar.Event, error)) {
	fake.createEventMutex.Lock()
	defer fake.createEventMutex.Unlock()
	fake.CreateEventStub = stub
}

func (fake *FakeCalendarService) CreateEventArgsForCall(i int) (string, *calendar.Event) {
	fake.createEventMutex.RLock()
	defer fake.createEventMutex.RUnlock()
	argsForCall := fake.createEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCalendarService) CreateEventReturns(result1 *calendar.Event, result2 error) {
	fake.createEventMutex.Lock()
	defer fake.createEventMutex.Unlock()
	fake.CreateEventStub = nil
	fake.createEventReturns = struct {
		result1 *calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) CreateEventReturnsOnCall(i int, result1 *calendar.Event, result2 error) {
	fake.createEventMutex.Lock()
	defer fake.createEventMutex.Unlock()
	fake.CreateEventStub = nil
	if fake.createEventReturnsOnCall == nil {
		fake.createEventReturnsOnCall = make(map[int]struct {
			result1 *calendar.Event
			result2 error
		})
	}
	fake.createEventReturnsOnCall[i] = struct {
		result1 *calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) DeleteEvent(arg1 string, arg2 string) error {
	fake.deleteEventMutex.Lock()
	ret, specificReturn := fake.deleteEventReturnsOnCall[len(fake.deleteEventArgsForCall)]
	fake.deleteEventArgsForCall = append(fake.deleteEventArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteEventStub
	fakeReturns := fake.deleteEventReturns
	fake.recordInvocation("DeleteEvent", []interface{}{arg1, arg2})
	fake.deleteEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCalendarService) DeleteEventCallCount() int {
	fake.deleteEventMutex.RLock()
	defer fake.deleteEventMutex.RUnlock()
	return len(fake.deleteEventArgsForCall)
}

func (fake *FakeCalendarService) DeleteEventCalls(stub func(string, string) error) {
	fake.deleteEventMutex.Lock()
	defer fake.deleteEventMutex.Unlock()
	fake.DeleteEventStub = stub
}

func (fake *FakeCalendarService) DeleteEventArgsForCall(i int) (string, string) {
	fake.deleteEventMutex.RLock()
	defer fake.deleteEventMutex.RUnlock()
	argsForCall := fake.deleteEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCalendarService) DeleteEventReturns(result1 error) {
	fake.deleteEventMutex.Lock()
	defer fake.deleteEventMutex.Unlock()
	fake.DeleteEventStub = nil
	fake.deleteEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCalendarService) DeleteEventReturnsOnCall(i int, result1 error) {
	fake.deleteEventMutex.Lock()
	defer fake.deleteEventMutex.Unlock()
	fake.DeleteEventStub = nil
	if fake.deleteEventReturnsOnCall == nil {
		fake.deleteEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCalendarService) GetEvent(arg1 string, arg2 string) (*calendar.Event, error) {
	fake.getEventMutex.Lock()
	ret, specificReturn := fake.getEventReturnsOnCall[len(fake.getEventArgsForCall)]
	fake.getEventArgsForCall = append(fake.getEventArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetEventStub
	fakeReturns := fake.getEventReturns
	fake.recordInvocation("GetEvent", []interface{}{arg1, arg2})
	fake.getEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCalendarService) GetEventCallCount() int {
	fake.getEventMutex.RLock()
	defer fake.getEventMutex.RUnlock()
	return len(fake.getEventArgsForCall)
}

func (fake *FakeCalendarService) GetEventCalls(stub func(string, string) (*calendar.Event, error)) {
	fake.getEventMutex.Lock()
	defer fake.getEventMutex.Unlock()
	fake.GetEventStub = stub
}

func (fake *FakeCalendarService) GetEventArgsForCall(i int) (string, string) {
	fake.getEventMutex.RLock()
	defer fake.getEventMutex.RUnlock()
	argsForCall := fake.getEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCalendarService) GetEventReturns(result1 *calendar.Event, result2 error) {
	fake.getEventMutex.Lock()
	defer fake.getEventMutex.Unlock()
	fake.GetEventStub = nil
	fake.getEventReturns = struct {
		result1 *calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) GetEventReturnsOnCall(i int, result1 *calendar.Event, result2 error) {
	fake.getEventMutex.Lock()
	defer fake.getEventMutex.Unlock()
	fake.GetEventStub = nil
	if fake.getEventReturnsOnCall == nil {
		fake.getEventReturnsOnCall = make(map[int]struct {
			result1 *calendar.Event
			result2 error
		})
	}
	fake.getEventReturnsOnCall[i] = struct {
		result1 *calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) ListCalendars() ([]*calendar.CalendarListEntry, error) {
	fake.listCalendarsMutex.Lock()
	ret, specificReturn := fake.listCalendarsReturnsOnCall[len(fake.listCalendarsArgsForCall)]
	fake.listCalendarsArgsForCall = append(fake.listCalendarsArgsForCall, struct {
	}{})
	stub := fake.ListCalendarsStub
	fakeReturns := fake.listCalendarsReturns
	fake.recordInvocation("ListCalendars", []interface{}{})
	fake.listCalendarsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCalendarService) ListCalendarsCallCount() int {
	fake.listCalendarsMutex.RLock()
	defer fake.listCalendarsMutex.RUnlock()
	return len(fake.listCalendarsArgsForCall)
}

func (fake *FakeCalendarService) ListCalendarsCalls(stub func() ([]*calendar.CalendarListEntry, error)) {
	fake.listCalendarsMutex.Lock()
	defer fake.listCalendarsMutex.Unlock()
	fake.ListCalendarsStub = stub
}

func (fake *FakeCalendarService) ListCalendarsReturns(result1 []*calendar.CalendarListEntry, result2 error) {
	fake.listCalendarsMutex.Lock()
	defer fake.listCalendarsMutex.Unlock()
	fake.ListCalendarsStub = nil
	fake.listCalendarsReturns = struct {
		result1 []*calendar.CalendarListEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) ListCalendarsReturnsOnCall(i int, result1 []*calendar.CalendarListEntry, result2 error) {
	fake.listCalendarsMutex.Lock()
	defer fake.listCalendarsMutex.Unlock()
	fake.ListCalendarsStub = nil
	if fake.listCalendarsReturnsOnCall == nil {
		fake.listCalendarsReturnsOnCall = make(map[int]struct {
			result1 []*calendar.CalendarListEntry
			result2 error
		})
	}
	fake.listCalendarsReturnsOnCall[i] = struct {
		result1 []*calendar.CalendarListEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) ListEvents(arg1 string, arg2 time.Time, arg3 time.Time) ([]*calendar.Event, error) {
	fake.listEventsMutex.Lock()
	ret, specificReturn := fake.listEventsReturnsOnCall[len(fake.listEventsArgsForCall)]
	fake.listEventsArgsForCall = append(fake.listEventsArgsForCall, struct {
		arg1 string
		arg2 time.Time
		arg3 time.Time
	}{arg1, arg2, arg3})
	stub := fake.ListEventsStub
	fakeReturns := fake.listEventsReturns
	fake.recordInvocation("ListEvents", []interface{}{arg1, arg2, arg3})
	fake.listEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCalendarService) ListEventsCallCount() int {
	fake.listEventsMutex.RLock()
	defer fake.listEventsMutex.RUnlock()
	return len(fake.listEventsArgsForCall)
}

func (fake *FakeCalendarService) ListEventsCalls(stub func(string, time.Time, time.Time) ([]*calendar.Event, error)) {
	fake.listEventsMutex.Lock()
	defer fake.listEventsMutex.Unlock()
	fake.ListEventsStub = stub
}

func (fake *FakeCalendarService) ListEventsArgsForCall(i int) (string, time.Time, time.Time) {
	fake.listEventsMutex.RLock()
	defer fake.listEventsMutex.RUnlock()
	argsForCall := fake.listEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCalendarService) ListEventsReturns(result1 []*calendar.Event, result2 error) {
	fake.listEventsMutex.Lock()
	defer fake.listEventsMutex.Unlock()
	fake.ListEventsStub = nil
	fake.listEventsReturns = struct {
		result1 []*calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) ListEventsReturnsOnCall(i int, result1 []*calendar.Event, result2 error) {
	fake.listEventsMutex.Lock()
	defer fake.listEventsMutex.Unlock()
	fake.ListEventsStub = nil
	if fake.listEventsReturnsOnCall == nil {
		fake.listEventsReturnsOnCall = make(map[int]struct {
			result1 []*calendar.Event
			result2 error
		})
	}
	fake.listEventsReturnsOnCall[i] = struct {
		result1 []*calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) UpdateEvent(arg1 string, arg2 string, arg3 *calendar.Event) (*calendar.Event, error) {
	fake.updateEventMutex.Lock()
	ret, specificReturn := fake.updateEventReturnsOnCall[len(fake.updateEventArgsForCall)]
	fake.updateEventArgsForCall = append(fake.updateEventArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *calendar.Event
	}{arg1, arg2, arg3})
	stub := fake.UpdateEventStub
	fakeReturns := fake.updateEventReturns
	fake.recordInvocation("UpdateEvent", []interface{}{arg1, arg2, arg3})
	fake.updateEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCalendarService) UpdateEventCallCount() int {
	fake.updateEventMutex.RLock()
	defer fake.updateEventMutex.RUnlock()
	return len(fake.updateEventArgsForCall)
}

func (fake *FakeCalendarService) UpdateEventCalls(stub func(string, string, *calendar.Event) (*calendar.Event, error)) {
	fake.updateEventMutex.Lock()
	defer fake.updateEventMutex.Unlock()
	fake.UpdateEventStub = stub
}

func (fake *FakeCalendarService) UpdateEventArgsForCall(i int) (string, string, *calendar.Event) {
	fake.updateEventMutex.RLock()
	defer fake.updateEventMutex.RUnlock()
	argsForCall := fake.updateEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCalendarService) UpdateEventReturns(result1 *calendar.Event, result2 error) {
	fake.updateEventMutex.Lock()
	defer fake.updateEventMutex.Unlock()
	fake.UpdateEventStub = nil
	fake.updateEventReturns = struct {
		result1 *calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) UpdateEventReturnsOnCall(i int, result1 *calendar.Event, result2 error) {
	fake.updateEventMutex.Lock()
	defer fake.updateEventMutex.Unlock()
	fake.UpdateEventStub = nil
	if fake.updateEventReturnsOnCall == nil {
		fake.updateEventReturnsOnCall = make(map[int]struct {
			result1 *calendar.Event
			result2 error
		})
	}
	fake.updateEventReturnsOnCall[i] = struct {
		result1 *calendar.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeCalendarService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createEventMutex.RLock()
	defer fake.createEventMutex.RUnlock()
	fake.deleteEventMutex.RLock()
	defer fake.deleteEventMutex.RUnlock()
	fake.getEventMutex.RLock()
	defer fake.getEventMutex.RUnlock()
	fake.listCalendarsMutex.RLock()
	defer fake.listCalendarsMutex.RUnlock()
	fake.listEventsMutex.RLock()
	defer fake.listEventsMutex.RUnlock()
	fake.updateEventMutex.RLock()
	defer fake.updateEventMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCalendarService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ google.CalendarService = new(FakeCalendarService)
