// Code generated by ADL CLI v0.20.5 on 2025-09-17 01:09:28. DO NOT EDIT.
// This file was automatically generated from an ADL (Agent Definition Language) specification.
// Manual changes to this file may be overwritten during regeneration.

package google

import (
	"context"
	"fmt"
	"time"

	config "github.com/inference-gateway/google-calendar-agent/config"
	zap "go.uber.org/zap"
	calendar "google.golang.org/api/calendar/v3"
	option "google.golang.org/api/option"
)

// CalendarService represents the google dependency interface
// Google Calendar API service for managing calendar events
type CalendarService interface {
	ListEvents(calendarID string, timeMin, timeMax time.Time) ([]*calendar.Event, error)
	CreateEvent(calendarID string, event *calendar.Event) (*calendar.Event, error)
	UpdateEvent(calendarID, eventID string, event *calendar.Event) (*calendar.Event, error)
	DeleteEvent(calendarID, eventID string) error
	GetEvent(calendarID, eventID string) (*calendar.Event, error)
	ListCalendars() ([]*calendar.CalendarListEntry, error)
	CheckConflicts(calendarID string, startTime, endTime time.Time) ([]*calendar.Event, error)
	GetCalendarID() string
}

// NewServiceFactory creates a new instance of CalendarService
func NewServiceFactory(logger *zap.Logger, cfg *config.Config) (CalendarService, error) {
	logger.Info("initializing Google Calendar dependency")

	// Check if we should use mock mode based on config
	if shouldUseMockMode(cfg) {
		logger.Info("Creating mock Google Calendar service")
		return NewMockCalendarService(logger, cfg), nil
	}

	logger.Info("Creating real Google Calendar service")
	return createRealCalendarService(context.Background(), logger, cfg)
}

// shouldUseMockMode determines if mock mode should be used based on config
func shouldUseMockMode(cfg *config.Config) bool {
	return cfg.Google.MockMode
}

// createRealCalendarService creates a real Google Calendar service using config
func createRealCalendarService(ctx context.Context, logger *zap.Logger, cfg *config.Config) (CalendarService, error) {
	var opts []option.ClientOption

	if cfg.Google.ServiceAccountJSON != "" {
		opts = append(opts, option.WithCredentialsJSON([]byte(cfg.Google.ServiceAccountJSON)))
	} else if cfg.Google.CredentialsPath != "" {
		opts = append(opts, option.WithCredentialsFile(cfg.Google.CredentialsPath))
	} else {
		return nil, fmt.Errorf("no Google credentials found: set GOOGLE_SERVICE_ACCOUNT_JSON or GOOGLE_CREDENTIALS_PATH")
	}

	scopes := []string{
		calendar.CalendarReadonlyScope,
		calendar.CalendarScope,
	}

	scopesOption := option.WithScopes(scopes...)
	allOptions := append([]option.ClientOption{scopesOption}, opts...)

	svc, err := calendar.NewService(ctx, allOptions...)
	if err != nil {
		return nil, fmt.Errorf("unable to create google calendar service: %w", err)
	}

	return &CalendarServiceImpl{service: svc, logger: logger, config: cfg}, nil
}

// CalendarServiceImpl implements the calendar service interface for Google Calendar API
type CalendarServiceImpl struct {
	service *calendar.Service
	logger  *zap.Logger
	config  *config.Config
}

// GetCalendarID returns the calendar ID from config or default to "primary"
func (g *CalendarServiceImpl) GetCalendarID() string {
	if g.config.Google.CalendarID != "" {
		return g.config.Google.CalendarID
	}
	return "primary"
}

// CreateEvent creates a new event in the calendar
func (g *CalendarServiceImpl) CreateEvent(calendarID string, event *calendar.Event) (*calendar.Event, error) {
	g.logger.Debug("creating event",
		zap.String("component", "google-calendar-service"),
		zap.String("operation", "create-event"),
		zap.String("calendarID", calendarID),
		zap.String("summary", event.Summary))

	createdEvent, err := g.service.Events.Insert(calendarID, event).Do()
	if err != nil {
		g.logger.Error("failed to create event",
			zap.String("component", "google-calendar-service"),
			zap.String("operation", "create-event"),
			zap.String("calendarID", calendarID),
			zap.Error(err))
		return nil, fmt.Errorf("unable to create event: %w", err)
	}

	g.logger.Debug("Successfully created event", zap.String("eventId", createdEvent.Id))
	return createdEvent, nil
}

// ListEvents lists the events in the calendar
func (g *CalendarServiceImpl) ListEvents(calendarID string, timeMin, timeMax time.Time) ([]*calendar.Event, error) {
	g.logger.Debug("listing events",
		zap.String("component", "google-calendar-service"),
		zap.String("operation", "list-events"),
		zap.String("calendarID", calendarID),
		zap.Time("timeMin", timeMin),
		zap.Time("timeMax", timeMax))

	call := g.service.Events.List(calendarID).
		TimeMin(timeMin.Format(time.RFC3339)).
		SingleEvents(true).
		OrderBy("startTime")

	if !timeMax.IsZero() {
		call = call.TimeMax(timeMax.Format(time.RFC3339))
	}

	events, err := call.Do()
	if err != nil {
		g.logger.Error("failed to list events",
			zap.String("component", "google-calendar-service"),
			zap.String("operation", "list-events"),
			zap.String("calendarID", calendarID),
			zap.Error(err))
		return nil, fmt.Errorf("unable to list events: %w", err)
	}

	g.logger.Debug("Successfully listed events", zap.Int("count", len(events.Items)))
	return events.Items, nil
}

// UpdateEvent updates an event by ID in the calendar
func (g *CalendarServiceImpl) UpdateEvent(calendarID, eventID string, event *calendar.Event) (*calendar.Event, error) {
	g.logger.Debug("updating event",
		zap.String("component", "google-calendar-service"),
		zap.String("operation", "update-event"),
		zap.String("calendarID", calendarID),
		zap.String("eventID", eventID),
		zap.String("summary", event.Summary))

	updatedEvent, err := g.service.Events.Update(calendarID, eventID, event).Do()
	if err != nil {
		g.logger.Error("failed to update event",
			zap.String("component", "google-calendar-service"),
			zap.String("operation", "update-event"),
			zap.String("calendarID", calendarID),
			zap.String("eventID", eventID),
			zap.Error(err))
		return nil, fmt.Errorf("unable to update event: %w", err)
	}

	g.logger.Debug("Successfully updated event", zap.String("eventId", updatedEvent.Id))
	return updatedEvent, nil
}

// DeleteEvent deletes an event by ID
func (g *CalendarServiceImpl) DeleteEvent(calendarID, eventID string) error {
	g.logger.Debug("deleting event",
		zap.String("component", "google-calendar-service"),
		zap.String("operation", "delete-event"),
		zap.String("calendarID", calendarID),
		zap.String("eventID", eventID))

	err := g.service.Events.Delete(calendarID, eventID).Do()
	if err != nil {
		g.logger.Error("failed to delete event",
			zap.String("component", "google-calendar-service"),
			zap.String("operation", "delete-event"),
			zap.String("calendarID", calendarID),
			zap.String("eventID", eventID),
			zap.Error(err))
		return fmt.Errorf("unable to delete event: %w", err)
	}

	g.logger.Debug("Successfully deleted event", zap.String("eventId", eventID))
	return nil
}

// GetEvent get a specific event by ID
func (g *CalendarServiceImpl) GetEvent(calendarID, eventID string) (*calendar.Event, error) {
	g.logger.Debug("getting event",
		zap.String("component", "google-calendar-service"),
		zap.String("operation", "get-event"),
		zap.String("calendarID", calendarID),
		zap.String("eventID", eventID))

	event, err := g.service.Events.Get(calendarID, eventID).Do()
	if err != nil {
		g.logger.Error("failed to get event",
			zap.String("component", "google-calendar-service"),
			zap.String("operation", "get-event"),
			zap.String("calendarID", calendarID),
			zap.String("eventID", eventID),
			zap.Error(err))
		return nil, fmt.Errorf("unable to get event: %w", err)
	}

	g.logger.Debug("Successfully retrieved event", zap.String("eventId", event.Id))
	return event, nil
}

func (g *CalendarServiceImpl) ListCalendars() ([]*calendar.CalendarListEntry, error) {
	return nil, fmt.Errorf("not implemented")
}

// CheckConflicts checks for conflicts of events in the calendar by given start and end time
func (g *CalendarServiceImpl) CheckConflicts(calendarID string, startTime, endTime time.Time) ([]*calendar.Event, error) {
	g.logger.Debug("checking conflicts",
		zap.String("component", "google-calendar-service"),
		zap.String("operation", "check-conflicts"),
		zap.String("calendarID", calendarID),
		zap.Time("startTime", startTime),
		zap.Time("endTime", endTime))

	events, err := g.service.Events.List(calendarID).
		TimeMin(startTime.Format(time.RFC3339)).
		TimeMax(endTime.Format(time.RFC3339)).
		SingleEvents(true).
		OrderBy("startTime").
		Do()

	if err != nil {
		g.logger.Error("failed to check conflicts",
			zap.String("component", "google-calendar-service"),
			zap.String("operation", "check-conflicts"),
			zap.String("calendarID", calendarID),
			zap.Error(err))
		return nil, fmt.Errorf("unable to check conflicts: %w", err)
	}

	var conflicts []*calendar.Event
	for _, event := range events.Items {
		if event.Start != nil && event.End != nil {
			eventStart, err1 := time.Parse(time.RFC3339, event.Start.DateTime)
			eventEnd, err2 := time.Parse(time.RFC3339, event.End.DateTime)

			if err1 == nil && err2 == nil {
				if eventStart.Before(endTime) && eventEnd.After(startTime) {
					conflicts = append(conflicts, event)
				}
			}
		}
	}

	g.logger.Debug("Successfully checked conflicts", zap.Int("conflictCount", len(conflicts)))
	return conflicts, nil
}

// MockCalendarService implements CalendarService for testing
type MockCalendarService struct {
	logger *zap.Logger
	config *config.Config
}

// NewMockCalendarService creates a new mock calendar service
func NewMockCalendarService(logger *zap.Logger, cfg *config.Config) *MockCalendarService {
	return &MockCalendarService{
		logger: logger,
		config: cfg,
	}
}

// GetCalendarID returns the calendar ID from config or default to "primary"
func (m *MockCalendarService) GetCalendarID() string {
	if m.config.Google.CalendarID != "" {
		return m.config.Google.CalendarID
	}
	return "primary"
}

// CreateEvent creates a mock event
func (m *MockCalendarService) CreateEvent(calendarID string, event *calendar.Event) (*calendar.Event, error) {
	m.logger.Debug("Mock: creating event", zap.String("summary", event.Summary))

	event.Id = fmt.Sprintf("mock-event-%d", time.Now().Unix())
	event.Status = "confirmed"

	return event, nil
}

// Implement other mock methods...
func (m *MockCalendarService) ListEvents(calendarID string, timeMin, timeMax time.Time) ([]*calendar.Event, error) {
	m.logger.Debug("Mock: listing events", zap.String("calendarID", calendarID))

	events := []*calendar.Event{
		{
			Id:          "mock-event-1",
			Summary:     "Mock Meeting 1",
			Description: "This is a mock meeting",
			Status:      "confirmed",
			Start: &calendar.EventDateTime{
				DateTime: timeMin.Add(time.Hour).Format(time.RFC3339),
			},
			End: &calendar.EventDateTime{
				DateTime: timeMin.Add(2 * time.Hour).Format(time.RFC3339),
			},
			Location: "Mock Office",
			HtmlLink: "https://calendar.google.com/mock1",
		},
		{
			Id:          "mock-event-2",
			Summary:     "Mock Event 2",
			Description: "Another mock event",
			Status:      "confirmed",
			Start: &calendar.EventDateTime{
				DateTime: timeMin.Add(3 * time.Hour).Format(time.RFC3339),
			},
			End: &calendar.EventDateTime{
				DateTime: timeMin.Add(4 * time.Hour).Format(time.RFC3339),
			},
			Location: "Mock Location 2",
			HtmlLink: "https://calendar.google.com/mock2",
		},
	}

	return events, nil
}
func (m *MockCalendarService) UpdateEvent(calendarID, eventID string, event *calendar.Event) (*calendar.Event, error) {
	m.logger.Debug("Mock: updating event", zap.String("eventId", eventID), zap.String("summary", event.Summary))

	event.Id = eventID
	event.Status = "confirmed"

	return event, nil
}
func (m *MockCalendarService) DeleteEvent(calendarID, eventID string) error {
	return nil
}
func (m *MockCalendarService) GetEvent(calendarID, eventID string) (*calendar.Event, error) {
	m.logger.Debug("Mock: getting event", zap.String("eventId", eventID))

	return &calendar.Event{
		Id:          eventID,
		Summary:     "Mock Event",
		Description: "This is a mock event for testing",
		Status:      "confirmed",
		Start: &calendar.EventDateTime{
			DateTime: "2024-01-01T10:00:00Z",
		},
		End: &calendar.EventDateTime{
			DateTime: "2024-01-01T11:00:00Z",
		},
		Location: "Mock Location",
		HtmlLink: "https://calendar.google.com/mock",
	}, nil
}
func (m *MockCalendarService) ListCalendars() ([]*calendar.CalendarListEntry, error) {
	return []*calendar.CalendarListEntry{}, nil
}
func (m *MockCalendarService) CheckConflicts(calendarID string, startTime, endTime time.Time) ([]*calendar.Event, error) {
	m.logger.Debug("Mock: checking conflicts",
		zap.String("calendarID", calendarID),
		zap.Time("startTime", startTime),
		zap.Time("endTime", endTime))

	mockConflictStart := time.Date(startTime.Year(), startTime.Month(), startTime.Day(), 10, 0, 0, 0, startTime.Location())
	mockConflictEnd := mockConflictStart.Add(time.Hour)

	if startTime.Before(mockConflictEnd) && endTime.After(mockConflictStart) {
		return []*calendar.Event{
			{
				Id:      "mock-conflict-event",
				Summary: "Mock Existing Meeting",
				Status:  "confirmed",
				Start: &calendar.EventDateTime{
					DateTime: mockConflictStart.Format(time.RFC3339),
				},
				End: &calendar.EventDateTime{
					DateTime: mockConflictEnd.Format(time.RFC3339),
				},
				Location: "Mock Conference Room",
			},
		}, nil
	}

	return []*calendar.Event{}, nil
}
